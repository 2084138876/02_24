#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

// 1 写一个函数返回参数二进制中1的个数

//方法一   
//int count_num_of_1(unsigned int n)
//{
//	// 原理:
//	// 11 的二进制是  1011
//	// 11%2 = 1 -> 1
//	// 11/2= 5 ->  101
//	// 5%2 =1  -> 1
//	// 5/2= 2  -> 10
//	// 2%2 =0  -> 0
//	// 2/2=1 ->  1
//	// 1%2 =1  ->1
//	// 1/2=0  结束
//	int count = 0;
//	while (n)
//	{
//		if (n % 2 == 1)
//			count++;
//		n /= 2;
//	}
//	return count;
//}

// 方法二
//int count_num_of_1(int n)
//{
//	//原理：
//	// 11 的二进制  1011
//	// 1  的二进制  0001
//	// 一个数与1进行按位与运算的结果就是这个数字在内存中存储的最后一位二进制数字
//	int count = 0;
//	int i = 0;
//	for (i = 0; i < 32; i++)
//	{
//		if (((n >> i) & 1) == 1)
//			count++;
//	}
//	return count;
//}

// 方法三
//int count_num_of_1(int n)
//{
//	// 原理：
//	// 11 的二进制  1101
//	// 10 的二进制  1100
//	// 按位与       1100
//	// 执行一次
//	//			1100
//	//			1011
//	//按位与	1000
//	// 执行两次
//	//			1000
//	//			0111
//	//按位与	0000
//	// 执行三次
//	//每执行一次  n&(n-1)   原来n的二进制里面的1就少1
//	int count = 0;
//	while (n)
//	{
//		n = n & (n - 1);
//		count++;
//	}
//	return count;
//	// n&(n-1)还可以用来判断一个数是不是二的n次方，
//	// 2的n次方的数字，二进制数字中只有一个1
//	// 如果n&(n-1)==0,那么这个数字就是2的n 次方，因为n&(n-1)每执行一次，n的二进制数字里面的1就少一个
//}
// 
//
//int main()
//{
//	int num = 0;
//	scanf("%d", &num);
//	int count =count_num_of_1(num);
//	printf("%d", count);
//	return 0;
//}

// 2 求两个数字的二进制位中不同位的个数

// 方法1
//int count_diff_bit(int m, int n)
//{
//	int count = 0;
//	int i = 0;
//	for (i = 0; i < 32; i++)
//	{
//		// (m>>i)&1 结果是数字m二进制从右往左第i位数字
//		if (((m >> i) & 1) != ((n >> i) & 1))
//		{
//			count++;
//		}
//	}
//	return count;
//}

// 方法二
//int count_diff_bit(int m, int n)
//{
//	//按位异或操作符 ^
//	//相同位 结果为0  不同位结果为1
//	int ret = m ^ n;
//	int count = 0;
//	//统计一下ret二进制中1的个数
//	while (ret)
//	{
//		ret = ret & (ret - 1);
//			count++;
//	}
//	return count;
//}
//
//int main()
//{
//	int m = 0;
//	int n = 0;
//	scanf("%d %d", &m, &n);
//	int r = count_diff_bit(m, n);
//	printf("%d", r);
//	return 0;
//}

// 3 获取一个整数二进制序列中所有的偶数位和奇数位，分别打印出二进制序列

//int main()
//{
//	int num = 0;
//	scanf("%d", &num);
//	int i = 0;
//	// 获取奇数位
//	for (i = 30; i >= 0; i -= 2)
//	{
//		// 31 右移30 来到第一位
//		//29  右移28  来到第一位
//		//27   右移226  来到第一位
//		printf("%d", (num >> i) & 1);
//	}
//	// 11 二进制 00000000000000000000000000001011
//	printf("\n");
//	// 获取i偶数位
//	for (i = 31; i >= 0; i -= 2)
//	{
//		// 32 右移31 来到第一位
//		//30  右移29  来到第一位
//		//28   右移27  来到第一位
//		printf("%d", (num >> i) & 1);
//	}
//
//
//	return 0;
//}
//sizeof返回值的类型是size_t类型的，是无符号整形 unsigned int 类型

//  4 判断下列代码输出的结果是什么
//int i;//全局变量不初始化，默认值是0；局部变量不初始化，默认值是随即值
//int main()
//{
//	i--;//-1
//	if (i > sizeof(i))// sizeof(i)==4,但是i是有符号整形
//		// i 会提升到无符号整形
//	{
//		printf(">\n");
//	}
//	else
//	{
//		printf("<\n");
//	}
//	return 0;
//
//}
//表达式中有不同类型的数据进行计算、比较，最终要进行  数据转化
//其中，类型大小小于整形的，要进行整形提升
// 类型大小大于等于整形的，要向上提升到表达式中较大的类型

// 5 输入数字，打印图案
//int main()
//{
//	int i = 0;
//	int j = 0;
//	int n = 0;
//	while (scanf("%d", &n)) //scanf如果获取成功，返回值是获取到的值的个数，获取失败返回值是EFO
//	{
//		for (i = 0; i < n; i++)
//		{
//			for (j = 0; j < n; j++)
//			{
//				if (i == j)
//				{
//					printf("*");
//				}
//				else if (i + j == n - 1)
//				{
//					printf("*");
//				}
//				else
//				{
//					printf(" ");
//				}
//			}
//			printf("\n");
//
//		}
//	}
//	return 0;
//}

//逻辑操作符，结果是真 为1 ，结果是假 为0；
// 6 获取某一年的某一月有多少天
//int is_leap_year(int year)
//{
//	if ( (year % 4 == 0) && (year % 100 != 0) || (year % 400 == 0) )
//	{
//		return 1;
//	}
//	return 0;
//}
//
//int main()
//{
//	int year = 0;
//	int month = 0;
//	scanf("%d %d", &year, &month);
//	// 1 3 5 7 8 10 12 月    31天
//	//    4 6   9  11 月     30天
//	// 2 月  28 ，闰年 29
//	int day[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
//					   1  2  3 ....月
//	//定义一个函数判断是否是 闰年,是闰年返回1 不是返回0
//	int r = is_leap_year(year);
//	if (r)
//	{
//		day[2]++;
//		printf("%d", day[month]);
//	}
//	
//	return 0;
//}
//
